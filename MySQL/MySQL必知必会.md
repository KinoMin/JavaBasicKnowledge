# MySQL 架构

和其它数据库相比，MySQL 有点与众不同，它的架构可以在多种不同场景中应用并发挥良好作用。主要体现在存储引擎的架构上， **插件式的存储引擎架构将查询处理和其它的系统任务以及数据的存储提取相分离** 。这种架构可以根据业务的需求和实际需要选择合适的存储引擎。

-   连接层：最上层是一些客户端和连接服务。**主要完成一些类似于连接处理、授权认证、及相关的安全方案。**在该层上引入了线程池的概念，为通过认证安全接入的客户端提供线程。同样在该层上可以实现基于 SSL 的安全链接。服务器也会为安全接入的每个安户端验证它斤且有的损作权限。
-   服务层：第二层服务层，主要完成大部分的核心服务功能，包括查询解析、分析、优化、缓存、以及所有的内置函数，所有跨存储引擎的功能也都在这一层实现，包括触发器、存储过程、视图等。
-   引擎层：第三层存储引擎层，存储引擎真正的负责了 MySQL 中数据的存储和提取，服务器通过 API 与存储引擎进行通信。不同的存储引擎具有的功能不同，这样我们可以根据自己的实际需要进行选取
-   存储层：第四层为数据存储层，主要是将数据存储在运行于该设备的文件系统之上，并完成与存储引擎的交互。

客户端请求 ---> 连接器（验证用户身份，给予权限）---> 查询缓存（存在缓存则直接返回，不存在则执行后续操作）---> 分析器（对 SQL 进行词法分析和语法分析操作）---> 优化器（主要对执行的 SQL 优化选择最优的执行方案方法）--->执行器（执行时会先看用户是否有执行权限，有才去使用这个引擎提供的接口）--->  去引擎层获取数据返回（如果开启查询缓存则会缓存查询结果）

![image-20210522215630488](https://gitee.com/xlshi/blog_img/raw/master/mac/20210522215632.png)

# 存储引擎

存储引擎是 MySQL 的组件，用于处理不同表类型的 SQL 操作。不同的存储引擎提供不同的存储机制、索引技巧、锁定水平等功能，使用不同的存储引擎，还可以获得特定的功能。

使用哪一种引擎可以灵活选择， **一个数据库中多个表可以使用不同引擎以满足各种性能和实际需求** ，使用合适的存储引擎，将会提高整个数据库的性能。

MySQL 服务器使用可插拔的存储引擎体系结构，可以从运行中的 MySQL 服务器加载或卸载存储引擎。

## 查看存储引擎

```sql
-- 查看支持的存储引擎
SHOW ENGINES;

-- 查看默认存储引擎
SHOW VARIABLES LIKE 'storage_engine';

-- 查看具体某一个表所使用的存储引擎，这个默认存储引擎被修改了!
show create table tablename;

-- 准确查看某个数据库中的某一表所使用的存储引擎
show table status like 'tablename';
show table status from database where name="tablename";
```

## 设置存储引擎

```sql
-- 建表时指定存储引擎。默认的就是 INNODB，不需要设置
CREATE TABLE t1 (i INT) ENGINE = INNODB;
CREATE TABLE t2 (i INT) ENGINE = CSV;
CREATE TABLE t3 (i INT) ENGINE = MEMORY;

-- 修改存储引擎
ALTER TABLE t ENGINE = InnoDB;

-- 修改默认存储引擎，也可以在配置文件 my.cnf 中修改默认引擎
SET default_storage_engine = NDBCLUSTER;
```

默认情况下，每当`CREATE TABLE`或`ALTER TABLE`不能使用默认存储引擎时，都会生成一个警告。为了防止在所需的引擎不可用时出现令人困惑的意外行为，可以启用`NO_ENGINE_SUBSTITUTION SQL`模式。如果所需的引擎不可用，则此设置将产生错误而不是警告，并且不会创建或更改表。

## 存储引擎对比

常见的存储引擎就 InnoDB、MyISAM、 Memory、NDB。InnoDB 现在是 MySQL 默认的存储引擎， **支持事务、行级锁定和外键。**

## 文件存储结构对比

在 MySQL 中建立任何一张数据表，在其数据目录对应的数据库目录下都有对应表的`.frm`文件，`.frm`文件是用来保存每个数据表的元数据（meta）信息，包括表结构的定义等，与数据库存储引擎无关，也就是任何存储引擎的数据表都必须有`.frm `文件，命名方式为数据表名`.frm`，如`user.frm`。

查看 MySQL 数据保存在哪里：`show variables like 'data%'` 。

MyISAM 物理文件结构为：

-   `.frm`文件：与表相关的元数据信息都存放在`frm`文件，包括表结构的定义信息等。
-   `.MYD`（MYData）文件：MyISAM 存储引擎专用，用于存储 MyISAM 表的数据。
-   ` .MYI`（MYIndex）文件：MyISAM 存储引擎专用，用于存储 MyISAM 表的索引相关信息。

InnoDB 物理文件结构为：

-   `.frm`文件：与表相关的元数据信息都存放在 frm 文件，包括表结构的定义信息等
-   `.ibd`文件或`.ibdata`文件：这两种文件都是存放 InnoDB 数据的文件，之所以有两种文件形式存放 InnoDB 的数据，是因为 InnoDB 的数据存储方式能够通过配置来决定是使用共享表空间存放存储数据，还是用独享表空间存放存储数据。

独享表空间存储方式使用`.ibd`文件，并且每个表一个`.ibd`文件共享表空间存储方式使用`.ibdata`文件，所有表共同使用一个`.ibdata`文件（或多个，可自己配置）。

1.  InnoDB 支持事务，MyISAM 不支持事务。这是 MySQL 将默认存储引擎从 MyISAM 变成 InnoDB 的重要原因之一；
2.  InnoDB 支持外键，而 MyISAM 不支持。对一个包含外键的 InnoDB 表转为 MyISAM 会失败：
3.  InnoDB 是聚簇索引，MyISAM 是非聚簇索引。聚簇索引的文件存放在主键索引的叶子节点上，因此 InnoDB 必须要有主键，通过主键索引效率很高。但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此，主键不应该过大，因为主键太大，其他索引也都会很大。而 MyISAM 是非聚集引，数据文件是分离的，索引保存的是数据文件的指针。主键索引和辅助索引是独立的。
4.  InnoDB 不保存表的具体行数，执行`select count(*) from table`时需要全表扫描。而 MyISAM 用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快：
5.  InnoDB 最小的锁粒度是行锁，MyISAM 最小的锁粒度是表锁。一个更新语句会锁住整张表，导致其他查询和更新都会被阻塞，因此并发访问受限。这也是 MySQL 将默认存储引擎从 MyISAM 变成 InnoDB 的重要原因之一。

|  对比项  |                          MyISAM                          |                            InnoDB                            |
| :------: | :------------------------------------------------------: | :----------------------------------------------------------: |
|  主外键  |                          不支持                          |                             支持                             |
|   事务   |                          不支持                          |                             支持                             |
|  行表锁  | 表锁，即使操作一条记录也会锁住整个表，不适合高并发的操作 |    行锁，操作时只锁住某一行，不影响其它行，适合高并发操作    |
|   缓存   |                只缓存索引，不缓存真实数据                | 不仅缓存索引还要缓存真实数据，对内存要求较高，而且内存大小对性能有决定性影响 |
|  表空间  |                            小                            |                              大                              |
|  关注点  |                           性能                           |                             事务                             |
| 默认安装 |                            是                            |                              是                              |

>   一张表，里面有 ID 自增主键，当 insert 了 17 条记录之后，删除了第 15,16,17 条记录，再把 MySQL 重启，再 insert 一条记录，这条记录的ID是18还是15? 
>
>   如果表的类型是 MyISAM，那么是 18。因为 MyISAM 表会把自增主键的最大 ID 记录到数据文件中，重启 MySQL 自增主键的最大 ID 也不会丢失：如果表的类型是 InnoDB，那么是 15。因为 InnoDB 表只是把自增主键的最大 ID 记录到内存中，所以重启数据库或对表进行 OPTION 操作，都会导致最大 ID 丢失。

>   哪个存储引擎执行`select count(*)`更快，为什么?
>   MyISAM 更快，因为 MyISAM 内部维护了一个计数器，可以直接调取。
>
>   -   在 MyISAM 存储引擎中，把表的总行数存储在磁盘上，当执行`select count(*) from t`时，直接返回总数据。
>   -   在 InnoDB 存储引擎中，跟 MyISAM 不一样，没有将总行数存储在磁盘上，当执行`select count(*) from t`时，会先把数据读出来，一行一行的累加，最后返回总数量。
>
>   InnoDB 中`count(*)`语句是在执行的时候，全表扫描统计总数量，所以当数据越来越大时，语句就越来越耗时了，为什么 InnoDB 引擎不像 MyISAM 引擎一样，将总行数存储到磁盘上？这跟 InnoDB 的事务特性有关，由于多版本并发控制（MVCC）的原因，InnoDB 表"应该返回多少行"也是不确定的。

# 数据类型

主要包括以下五大类：

-   整数类型：BIT、BOOL、TINY INT、SMALL INT、MEDIUM INT、INT、BIG INT；
-   浮点数类型：FLOAT、DOUBLE、DECIMAL；
-   字符串类型：CHAR、CARCHAR、TINY TEXT、TEXT、MEDIUM TEXT、LONGTEXT、TINY BLOB、BLOB、MEDIUM BLOB、LONG BLOB；
-   日期类型：Date、DateTIme、TImeStamp、TIme、Year；
-   其他数据类型：BINARY、VARBINARY、ENUM、SET、Geometry、Point、MultiPoint、LineString、LineString、MultiLineString、Polygon、GeometryCollection 等。

![image-20210523094634319](./images/image-20210523094634319.png)

![image-20210523094701376](./images/image-20210523094701376.png)

![image-20210523094717114](./images/image-20210523094717114.png)

>   CHAR 和 VARCHAR 的区别？
>
>   char 是固定长度，varchar 长度可变：
>
>   char(n) 和 varchar(n) 中括号中 n 代表字符的个数，并不代表字节个数，比如 CHAR(30) 就可以存储 30 个字符。
>
>   存储时，前者不管实际存储数据的长度，直接按 char 规定的长度分配存储空间；而后者会根据实际存储的数据分配最终的空间。
>
>   相同点：
>
>   1.  char(n)，varchar(n) 中 n 都代表字符的个数；
>   2.  超过 char，varchar 最大长度 n 的限制后，字符串会被截断。
>
>   不同点：
>
>   1.  char 不论实际存储的字符数都会占用 n 个字符的空间，而 varchar 只会占用实际字符应该占用的字节空间加 1（实际长度 length，0 <= length < 255）或加 2（length > 255）。因为 varchar 保存数据时除了要保存字符串之外还会加一个字节来记录长度（如果列声明长度大于 255 则使用两个字节来保存长度）。
>   2.  能存储的最大空间限制不一样；char 的存储上限是 255 字节。
>   3.  char 在存储时会截断尾部的空格，而 varchar 不会。
>
>   char 适合存储很短的、一般固定长度的字符串。例如，char 非常适合存储密码的 MD5 值，因为这是一个定长的值。对于非常短的列，char 比 varchar 在存储空间上也更有效率。

>   列的字符串类型可以是什么？
>
>   字符串类型是：SET、BLOB、ENUM、CHAR、TEXT、VARCHAR。

>   BLOB 和 TEXT 有什么区别？
>
>   BLOB 是一个二进制对象，可以容纳可变数量的数据。有四种类型的 BLOB：TINYBLOB、BLOB、MEDIUMBLO 和 LONGBLOB。
>
>   TEXT 是一个不区分大小写的 BLOB。四种 TEXT 类型：TINYTEXT、TEXT、MEDIUMTEXT 和 LONGTEXT。
>
>   BLOB 保存二进制数据，TEXT 保存字符数据。

# 索引

MySQL 官方对索引的定义为：索引（index）是帮助 MySQL 搞笑获取数据的数据结构，所以说 **索引的本质是：数据结构。**

索引的目的在于提高查询效率，可以类比字典、火车站的车次表、图书的目录等。

可以简单的理解为"排好序的快速查找数据结构"，数据本身之外， **数据库还维护着一个满足特定查找算法的数据结构，**这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查询算法。这种数据结构就是索引。下图是一种可能的索引方式示例：

![image-20210523100019331](./images/image-20210523100019331.png)

左边的数据表一共有两列七条记录，最左边的是数据记录的物理地址。为了加快 Col2 的查找，可以维护一个右边所示的二叉查找树，每个节点分别包含索引键值，和一个指向对应数据记录物理地址的指针，这样就可以运用二叉查找在一定的复杂度上获取到对应的数据，从而快速检索出符合条件的记录。

索引本身也很大，不可能全部存储在内存中， **一般以索引文件的形式存储在磁盘上。**

平常说的索引，没有特别指明的话，就是 B+ 树（多路搜索树，不一定是二叉树）结构组织的索引。其中聚集索引、次要索引、覆盖索引、复合索引、前缀索引、唯一索引默认都是使用 B+ 树索引，统称索引。此外还有哈希索引等。

## 基本语法

-   创建：

    -   创建索引：`CREATE [UNIQUE] INDEX indexName ON mytable(username(length));`

    如果是 CHAR、VARCHAR 类型，length 可以小于字段实际长度；如果是 BLOB 和 TEXT 类型，必须指定 length。

    -   修改表结构（添加索引）：`ALTER table tableName ADD [UNIQUE] INDEX indexName(cloumnName)`

-   删除：`DROP INDEX [indexName] ON mytable;`

-   查看：`SHOW INDEX FROM table_name\G`，可以通过添加`\G`来格式化输出信息

-   使用 ALTER 命令

    -   `ALTER TABLE tbl_name ADD PRIMARY KEY (column_list);`该语句添加一个主键，这意味着索引值必须是唯一的，且不能为 NULL。
    -   `ALTER TABLE tbl_name ADD UNIQUE index_name(column_list);`这条语句创建索引的值必须是唯一的（除了 NULL 外，NULL 可能会出现多次）。
    -   `ALTER TABLE tbl_name ADD INDEX index_name(column_list);`添加普通索引，索引值可出现多次。
    -   `ALTER TABLE tbl_name ADD FULLTEXT index_name(column_list);`该语句指定了索引为 FULLTEXT，用于全文索引。

## 优势

-   提高数据检索效率，降低数据库 IO 成本
-   降低数据排序的成本，降低 CPU 的消耗

## 劣势

-   索引也是一张表，保存了主键和索引字段，并指向实体表的记录，所以也需要占用内存
-   虽然索引大大提高了查询速度，同时却会降低更新表的速度，如对表进行 INSERT、UPDATE 和 DELETE。因为更新表时，MySQL 不仅要保存数据，还要保存一下索引文件每次更新添加了索引列的字段，都会调整因为更新所带来的键值变化后的索引信息

## MySQL 索引分类

### 数据结构角度

-   B+ 树索引
-   Hash 索引
-   Full-Text 全文索引
-   R-Tree 索引

### 从物理存储角度

-   聚集索引（clustered index）

-   非聚集索引（non-clustered index），也叫辅助索引（secondary index）

    聚集索引和非聚集索引都是 B+ 树结构

### 从逻辑角度

-   主键索引：主键索引是一种特殊的唯一索引，不允许有空值
-   普通索引或者单列索引：每个索引只包含单个列，一个表可以有多个单列索引
-   多列索引（复合索引、联合索引）：复合索引指多个字段上创建的索引，只有在查询条件中使用了创建索引时的第一个字段，索引才会被使用。使用复合索引时遵循最左前缀集合
-   唯一索引或者非唯一索引
-   空间索引：空间索引是对空间数据类型的字段建立的索引，MySQL 中的空间数据类型有 4 种，分别是 GEOMETRY、POINT、 LINESTRING、 POLYGON。MySQL 使用 SPATIAL 关键字进行扩展，使得能够用于创建正规索引类型的语法创建空间索引。创建空间索引的列，必须将其声明为 NOT NULL，空间索引只能在存储引擎为 MYISAM 的表中创建

## MySQL 索引结构

**首先要明白索引（index）是在存储引擎（storage engine）层面实现的，而不是 server 层面。** 不是所有的存储引擎都支持所有的索引类型。即使多个存储引擎支持某一索引类型，它们的实现和行为也可能有所差别。

### B+Tree 索引

MyISAM 和 InnoDB 存储引擎，都使用 B+ Tree 的数据结构，它相对与 B-Tree 结构，所有的数据都存放在叶子节点上，且把叶子节点通过指针连接到一起，形成了一条数据链表，以加快相邻数据的检索效率。

#### B-Tree

B-Tree 是为磁盘等外存储设备设计的一种平衡查找树。系统从磁盘读取数据到内存时是以磁盘块（block）为基本单位的，位于同一个磁盘块中的数据会被一次性读取出来，而不是需要什么取什么。InnoDB 存储引擎中有页（Page）的概念，页是其磁盘管理的最小单位。InnoDB 存储引擎中默认每个页的大小为 16KB，可通过参数`innodb_ page_ size`将页的大小设置为 4K、8K、16K，在 MySQL 中可通过如下命令查看页的大小：`show variables like 'innodb_ page_ size'`；

而系统一个磁盘块的存储空间往往没有这么大，因此 InnoDB 每次申请磁盘空间时都会是若干地址连续磁盘块来达到页的大小 16KB。InnoDB 在把磁盘数据读入到磁盘时会以页为基本单位，在查询数据时如果一个页中的每条数据都能有助于定位数据记录的位置，这将会减少磁盘 I/O 次数，提高查询效率。

B-Tree 结构的数据可以让系统高效的找到数据所在的磁盘块。为了描述 B-Tree， 首先定义一条记录为一个二元组 [key, data]，key 为记录的键值，对应表中的主键值，data 为一行记录中除主键外的数据。对于不同的记录，key 值互不相同。

一棵 m 阶的 B-Tree 有如下特性：

1.  每个节点最多有 m 个孩子
2.  除了根节点和叶子节点外，其它每个节点至少有 Ceil(m/2) 个孩子
3.  若根节点不是叶子节点，则至少有 2 个孩子
4.  所有叶子节点都在同一层，且不包含其它关键字信息
5.  每个非终端节点包含 n 个关键字信息（PO,1.1...Pn, k1...kn）
6.  关键字的个数 n 满足：ceil(m/2)-1 <= n <= m-1
7.  ki(i=1...n) 为关键字，且关键字升序排序
8.  Pi(i=1...n) 为指向子树根节点的指针。P(i-1) 指向的子树的所有节点关键字均小于 ki，但都大于 k(i-1)

B-Tree 中的每个节点根据实际情况可以包含大量的关键字信息和分支，如下图所示为一个 3 阶的 B-Tree：

![image-20210523223125711](./images/image-20210523223125711.png)

每个节点占用一个盘块的磁盘空间，一个节点上有两个升序排序的关键字和三个指向子树根节点的指针，指针存储的是子节点所在磁盘块的地址。两个关键词划分成的三个范围域对应三个指针指向的子树的数据的范围域。以根节点为例，关键字为 17 和 35，P1 指针指向的子树的数据范围为小于 17，P2 指针指向的子树的数据范围为 17~35，P3 指针指向的子树的数据范围为大于 35。 

模拟查找关键字 29 的过程:

1.  根据根节点找到磁盘块 1，读入内存。[磁盘 I/O 操作第 1 次]
2.  比较关键字 29 在区间（17，35）找到磁盘块 1 的指针 P2。
3.  根据 P2 指针找到磁盘块 3，读入内存。[磁盘 I/O 操作第 2 次]
4.  比较关键字 29 在区间（26，30），找到磁盘块 3 的指针 P2。
5.  根据 P2 指针找到磁盘块 8，读入内存。[磁盘 I/O 操作第 3 次]
6.  在磁盘块 8 中的关键字列表中找到关键字 29。

分析上面过程，发现需要 3 次磁盘 I/O 操作，和 3 次内存查找操作。由于内存中的关键字是一个有序表结构，可以利用二分法查找提高效率。而 3 次磁盘 I/O 操作是影响整个 B-Tree 查找效率的决定因素。B-Tree 相对于 AVLTree 缩减了节点个数，使每次磁盘 I/O 取到内存的数据都发挥了作用，从而提高了查询效率。

#### B+Tree

B+Tree 是在 B-Tree 基础上的一种优化，使其更适合实现外存储索引结构，InnoDB 存储引擎就是用 B+Tree 实现其索引结构。从上一节中的 B-Tree 结构图中可以看到每个节点中不仅包含数据的 key 值，还有 data 值。而每一个页的存储空间是有限的，如果 data 数据较大时将会导致每个节点（即一个页）能存储的 key 的数量很小，当存储的数据量很大时同样会导致 B-Tree 的深度较大，增大查询时的磁盘 I/O 次数，进而影响查询效率。 **在 B+Tree 中，所有数据记录节点都是按照键值大小顺序存放在同一层的叶子节点上，而非叶子节点上只存储 key 值信息，这样可以大大加大每个节点存储的 key 值数量，降低 B+Tree 的高度。**

B+Tree 相对于 B-Tree 有几点不同：

1.  非叶子节点只存储键值信息；
2.  所有叶子节点之间都有一个链指针；
3.  数据记录都存放在叶子节点中。

将上一节中的 B-Tree 优化，由于 B+Tree 的非叶子节点只存储键值信息，假设每个磁盘块能存储 4 个键值及指针信息，则变成 B+Tree 后其结构如下图所示：

![image-20210523225651511](./images/image-20210523225651511.png)

通常在 B+Tree 上有两个头指针，一个指向根节点，另一个指向关键字最小的叶子节点，而且所有叶子节点（即数据节点）之间是一种链式环结构。因此可以对 B+Tree 进行两种查找运算：一种是对于主键的范围查找和分页查找，另一种是从根节点开始，进行随机查找。

可能上面例子中只有 22 条数据记录，看不出 B+Tree 的优点，下面做一个推算：

InnoDB 存储引擎中页的大小为 16KB，一般表的主键类型为 INT（占用 4 个字节）或 BIGINT（占用 8 个字节），指针类型也一般为 4 或 8 个字节，也就是说一个页（B+Tree 中的一个节点）中大概存储 `16KB/(8B+8B)=1K` 个键值（因为是估值，为方便计算，这里的 K 取值为`10^3`）。也就是说一个深度为 3 的 B+Tree 索引可以维护 `10^3 * 10^3 * 10^3 = 10` 亿条记录。

实际情况中每个节点可能不能填充满，因此在数据库中，B+Tree 的高度一般都在 2-4 层。MySQL 的 InnoDB 存储引擎在设计时是将根节点常驻内存的，也就是说查找某一键值的行记录时最多只需要 1~3 次磁盘 I/O 操作。

#### B+Tree 性质

1.  通过上面的分析，我们知道 IO 次数取决于 B+Tree 的高度 h，假设当前数据表的数据为 N，每个磁盘块的数据项的数量是 m，则有 `h=log(m+1)N`，当数据量 N 一定的情况下，m 越大，h 越小；而 m = 磁盘块的大小 / 数据项的大小，磁盘块的大小也就是一个数据页的大小，是固定的，如果数据项占的空间越小，数据项的数量越多，树的高度越低。这就是为什么每个数据项，即索引字段要尽量的小，比如 int 占 4 字节，要比 bigint 8 字节少一半。这也是为什么 B+Tree 要求把真实的数据放到叶子节点而不是内层节点，一旦放到内层节点，磁盘块的数据项会大幅度下降，导致树增高。当数据项等于 1 时将会退化成线性表。
2.  当 B+Tree 的数据项是复合的数据结构，比如（name，age，sex）的时候，B+Tree 是按照从左到右的顺序来建立搜索树的，比如当（张三，20，F）这样的数据来检索的时候，B+Tree 会优先比较 name 来确定下一步的所搜方向，如果 name 相同再依次比较 age 和 sex，最后得到检索的数据；但当（20，F）这样的没有 name 的数据来的时候，B+Tree 就不知道下一步该查哪个节点，因为建立搜索树的时候 name 就是第一个比较因子，必须要先根据 name 来搜索才能知道下一步去哪里查询。比如当（张三，F）这样的数据来检索时，B+Tree 可以用 name 来指定搜索方向，但下一个字段 age 的缺失，所以只能把名字等于张三的数据都找到，然后再匹配性别是 F 的数据了，这个是非常重要的性质，即 **索引的最左匹配特性。**

#### MyISAM 主键索引与辅助索引的结构

MyISAM 引擎的索引文件和数据文件是分离的。 **MyISAM 引擎索引结构的叶子节点的数据域，存放的并不是实际的数据记录，而是数据记录的地址。** 索引文件与数据文件分离，这样的索引称为"非聚簇索引"。MyISAM 的主索引与辅助索引区别并不大，只是主键索引不能有重复的关键字。

![image-20210523231529878](./images/image-20210523231529878.png)

在 MyISAM 中，索引（含叶子节点）存放在单独的`.myi`文件中，叶子节点存放的是数据的物理地址偏移量（通过偏移量访问就是随机访问，速度很快）。

主索引是指主键索引，键值不可能重复；辅助索引则是普通索引，键值可能重复。

通过索引查找数据的流程：先从索引文件中查找到索引节点，从中拿到数据的文件指针，再到数据文件中通过文件指针定位了具体的数据。辅助索引类似。

##### InnoDB 主键索引与辅助索引的结构

InnoDB 引擎索引结构的叶子节点的数据域，存放的就是实际的数据记录（对于主索引，此处会存放表中所有的数据记录；对于辅助索引此处会引用主键，检索的时候通过主键到主键索引中找到对应数据行），或者说，InnoDB 的数据文件本身就是主键索引文件，这样的索引被称为“聚簇索引”，一个表只能有一个聚簇索引。

**主键索引：**

我们知道 InnoDB 索引是聚集索引，它的索引和数据是存入同一个`.idb`文件中的，因此它的索引结构是在同一个树节点中同时存放索引和数据，如下图中最底层的叶子节点有三行数据，对应于数据表中的 id、stu_ id、name 数据项。

![image-20210524230642750](images/image-20210524230642750.png)

在 InnoDB 中，索引分叶子节点和非叶子节点，非叶子节点就像新华字典的目录，单独存放在索引段中，叶子节点则是顺序排列的，在数据段中，InnoDB 的数据文件可以按照表来切分（只需要开启 `innodb_ file_ per_ table`），切分后存放在 `xxx.ibd` 中，默认不切分，存放在`xxx.ibdata`中。

**辅助（非主键）索引：**

这次我们以示例中学生表中的 name 列建立辅助索引，它的索引结构跟主键索引的结构有很大差别，在最底层的叶子结点有两行数据，第一行的字符串是辅助索引，按照 ASCII 码进行排序，第二行的整数是主键的值。这就意味着，对 name 列进行条件搜索，需要两个步骤：

1.  在辅助索引上检索 name，到达其叶子节点获取对应的主键；
2.  使用主键在主索引上再进行对应的检索操作

这也就是所谓的“回表查询”

![image-20210524231050881](images/image-20210524231050881.png)

##### InnoDB 索引结构需要注意的点

1.  数据文件本身就是索引文件
2.  表数据文件本身就是按 B+Tree 组织的一个索引结构文件
3.  聚集索引中叶节点包含了完整的数据记录
4.  InnoDB 表必须要有主键，并且推荐使用整型自增主键

正如上面介绍 InnoDB 存储结构，索引与数据是共同存储的，不管是主键索引还是辅助索引，在查找时都是通过先查找到索引节点才能拿到相对应的数据，如果在设计表结构时没有显式指定索引列的话，MySQL 会从表中选择数据不重复的列建立索引，如果没有符合的列，则 MySQL 自动为 InnoDB 表生成一个隐含字段作为主键，并且这个字段长度为 6 个字节，类型为整型。

>   为什么推荐使用整型自增主键而不是选择 UUID？
>
>   -   UUID 是字符串，比整型消耗更多的存储空间；
>   -   在 B+Tree 中进行查找时需要跟经过的节点值比较大小，整型数据的比较运算比字符串更快速；
>   -   自增的整型索引在磁盘中会连续存储，在读取一页数据时也是连续；UUID 是随机产生的，读取的上下两行数据存储是分散的，不适合执行`where id > 5 && id <20`的条件查询语句；
>   -   在插入或删除数据时，整型自增主键会在叶子结点的末尾建立新的叶子节点，不会破坏左侧子树的结构；UUID 主键很容易出现这样的情况，B+Tree  为了维持自身的特性，有可能会进行结构的重构，消耗更多的时间。

>   为什么非主键索引结构叶子节点存储的是主键值？
>
>   保证数据一致性和节省存储空间，可以这么理解：商城系统订单表会存储一个用户 ID 作为关联外键，而不推荐存储完整的用户信息，因为当我们用户表中的信息（真实名称、手机号、收货地址..）修改后，不需要再次维护订单表的用户数据，同时也节省了存储空间。

### Hash 索引

主要就是通过 Hash 算法（常见的 Hash 算法有直接定址法、平方取中法、折叠法、除数取余法、随机数法），将数据库字段数据转换成定长的 Hash 值，与这条数据的行指针一并存入 Hash 表的对应位置；如果发生 Hash 碰撞（两个不同关键字的 Hash 值相同），则在对应 Hash 键下以链表形式存储。

检索算法：在检索查询时，就再次对待查关键字再次执行相同的 Hash 算法，得到 Hash 值，到对应 Hash 表对应位置取出数据即可，如果发生 Hash 碰撞，则需要在取值时进行筛选。目前使用 Hash 索引的数据库并不多，主要有 Memory 等。

MySQL 目前有 Memory 引擎和 NDB 引擎支持 Hash 索引。

### Full-Text 全文索引

- 全文索引也是 MyISAM 的一种特殊索引类型，主要用于全文索引，InnoDB 从 MySQL 5.6 版本提供对全文索引的支持。
- 它用于替代效率较低的 LIKE 模糊匹配操作，而且可以通过多字段组合的全文索引一次性全模糊匹配多个字段。
- 同样使用 B-Tree 存放索引数据，但使用的是特定的算法，将字段数据分割后再进行索引（一般每 4 个字节一次分割），索引文件存储的是分割前的索引字符串集合，与分割后的索引信息，对应 B-Tree 结构的节点存储的是分割后的词信息以及它在分割前的索引|字符串集合中的位置。

### R-Tree 空间索引

空间索引是 MyISAM 的一种特殊索引类型，主要用于地理空间数据类型。

> 为什么 MySQL 索引要用 B+Tree 而不是 B-Tree？
>
> 用 B+Tree 不用 B-Tree 考虑的是 IO 对性能的影响，B-Tree 的每个节点都存储数据，而 B+Tree 只有叶子节点才存储数据，所以查找相同数据量的情况下，B-Tree 的高度更高，IO 更频繁。数据库索引是存储在磁盘上的，当数据量大时，就不能把整个索引全部加载到内存了，只能逐一加载每一个磁盘页（对应索引树的节点）。其中在MySQL 底层对 B+Tree 进行进一步优化：在叶子节点中是双向链表，且在链表的头结点和尾节点也是循环指向的。

> 为什么不采用 Hash 方式？
>
> 因为 Hash 索引底层是哈希表，哈希表是一种以 key-value 存储数据的结构， 所以多个数据在存储关系上是完全没有任何顺序关系的，所以，对于区间查询是无法直接通过索引查询的，就需要全表扫描。所以，哈希索引只适用于等值查询的场景。而 B+Tree 是一种多路平衡查询树,所以他的节点是天然有序的（左子节点小于父节点、父节点小于右子节点），所以对于范围查询的时候不需要做全表扫描。
>
> 哈希索引不支持多列联合索引的最左匹配规则，如果有大量重复键值得情况下，哈希索引的效率会很低，因为存在哈希碰撞问题。

## 哪些情况需要创建索引

1. 主键自动建立唯一索引
2. 频繁作为查询条件的字段
3. 查询中与其他表关联的字段，外键关系建立索引
4. 单键/组合索引的选择问题，高并发下倾向创建组合索引
5. 查询中排序的字段，排序字段通过索引访问大幅提高排序速度
6. 查询中统计或分组字段

## 哪些情况不需要创建索引

1. 表记录太少
2. 经常增删改的表
3. 数据重复且分布均匀的表字段，只应该为最经常查询和最经常排序的数据列建立索引（如果某个数据类包含太多的重复数据，建立索引没有太大意义）
4. 频繁更新的字段不适合创建索引（会加重 IO 负担）
5. where 条件里用不到的字段不创建索引

## MySQL 高效索引

覆盖索引（Covering Index），或者叫索引覆盖，也就是平时所说的不需要回表操作

- 就是 select 的数据列只用从索引中就能够取得，不必读取数据行，MySQL 可以利用索引返回 select 列表中的字段，而不必根据索引再次读取数据文件，换句话说查询列要被所建的索引覆盖。
- 索引是高效找到行的一个方法，但是一般数据库也能使用索引找到一个列的数据，因此它不必读取整个行。毕竟索引叶子节点存储了它们索引的数据，当能通过读取索引就可以得到想要的数据，那就不需要读取行了。一个索引包含（覆盖）满足查询结果的数据就叫做覆盖索引。
- 判断标准
    使用 explain，可以通过输出的 extra 列来判断，对于一个索引覆盖查询，显示为 using index，MySQL 查询优化器在执行查询前会决定是否有索弓|覆盖查询

# MySQL 查询

> `count(*)`和`count(1)`和`count(列名)`区别？
>
> 执行效果上：
>
> - `count(*)`包括了所有的列，相当于行数，在统计结果的时候，不会忽略列值为 NULL
> - `count(1)`包括了所有列，用 1 代表代码行，在统计结果的时候，不会忽略列值为 NULL
> - `count(列名)`只包括列名那一列，在统计结果的时候，会忽略列值为空（这里的空不是只空字符串或者 0，而是表示 NULL）的计数，即某个字段值为 NULL 时，不统计。
>
> 执行效率上：
>
> - 列名为主键，`count(列名)`会比`count(1)`快
> - 列名不为主键，`count(1)`会比`count(列名)`快
> - 如果表多个列并且没有主键，则`count(1)`的执行效率优于`count(*)`
> - 如果有主键，则`select count (主键)`的执行效率是最优的
> - 如果表只有一个字段，则`select count(*)`最优

> MySQL 中 in 和 exists 的区别？
>
> - exists：exists 对外表用 loop 逐条查询，每次查询都会查看 exists 的条件语句，当 exists 里的条件语句能够返回记录行时（无论记录行是的多少，只要能返回），条件就为真，返回当前 loop 到的这条记录；反之，如果 exists 里的条件语句不能返回记录行，则当前 loop 到的这条记录被丢弃，exists 的条件就像一个 bool 条件， 当能返回结果集则为 true，不能返回结果集则为 false
> - in：in 查询相当于多个 or 条件的叠加
>     `SELECT * FROM A WHERE A.id IN (SELECT id FROM B);`
>     `SELECT * FROM A WHERE EXISTS (SELECT * from B WHERE B.id = A.id);`
>
> **如果查询的两个表大小相当，那么用 in 和 exists 差别不大。**
>
> 如果两个表中一个较小，一个是大表，则子查询表大的用 exists；子查询表小的用 in。

> UNION 和 UNION ALL 区别？
>
> UNION 和 UNION ALL 都是将两个结果集合并为一个，两个要联合的 SQL 语句字段个数必须一样，而且字段类型要"相容”（一致） ;
>
> - UNION 在进行表连接后会筛选掉重复的数据记录（效率较低），而 UNION ALL 则不会去掉重复的数据记录；
> - UNION 会按照字段的顺序进行排序，而 UNION ALL 只是简单的将两个结果合并就返回。

## SQL 执行顺序

- 手写

```sql
SELECT DISTINCT <select_list>
FROM <left_table> <join_type>
JOIN <right_table> ON <join_condition>
WHERE <where_condition>
GROUP BY <group_by_list>
HAVING <having_condition>
ORDER BY <order_by_condition>
LIMIT <limit_number>
```

- 机读

```sql
FROM <left_table>
ON <join_condition>
<join_type> JOIN <right_table>
WHERE <where_condition>
GROUP BY <group_by_list>
HAVING <having_condition>
SELECT
DISTINCT <select_list>
ORDER BY <order_by_condition>
LIMIT <limit_number>
```

- 总结

![image-20210525224854549](images\image-20210525224854549.png)

## Join 图

![image-20210525225114158](images\image-20210525225114158.png)

# MySQL 事务

MySQL 事务主要用于处理操作量大，复杂度高的数据。比如说，在人员管理系统中，你删除一个人员，你即需要删除人员的基本资料，也要删除和该人员相关的信息，如信箱，文章等等，这样，这些数据库操作语句就构成一一个事务。

## ACID —— 事务基本要素

事务是由一组 SQL 语句组成的逻辑处理单元，具有 4 个属性，通常简称为事务的 ACID 属性。

- A（Atomicity）原子性：整个事务中的所有操作，要么全部完成，要么全部不完成，不可能停滞在中间某个环节。事务在执行过程中发生错误，会被回滚（Rolback）到事务开始前的状态，就像这个事务从来没有执行过一样
- C（Consistency）一致性：在事务开始之前和事务结束以后，数据库的完整性约束没有被破坏
- I（Isolation）隔离性：一个事务的执行不能其它事务干扰。即一个事务内部的操作及使用的数据对其它并发事务是隔离的，并发执行的各个事务之间不能互相干扰
- D（Durability）持久性：在事务完成以后，该事务所对数据库所作的更改便持久的保存在数据库之中，并不会被回滚

**并发事务处理带来的问题：**

- 更新丢失（Lost Update）：事务 A 和事务 B 选择同一行， 然后基于最初选定的值更新该行时，由于两个事务都不知道彼此的存在，就会发生丢失更新问题
- 脏读（Dirty Reads）：事务 A 读取了事务 B 更新的数据，然后B回滚操作，那么 A 读取到的数据是脏数据
- 不可重复读（Non-Repeatable Reads）：事务 A 多次读取同一数据，事务 B 在事务 A 多次读取的过程中，对数据作了更新并提交，导致事务 A 多次读取同一数据时，结果不一致。
- 幻读（Phantom Reads）：幻读与不可重复读类似。它发生在一个事务 A 读取了几行数据，接着另一个并发事务 B 插入了一些数据时。在随后的查询中，事务 A 就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。

**幻读和不可重复读的区别：**

- 不可重复读的重点是修改：在同一事务中，同样的条件，第一次读的数据和第二次读的数据不一样。（因为中间有其他事务提交了修改）
- 幻读的重点在于新增或者删除：在同一事务中，同样的条件,，第一次和第二次读出来的记录数不一样。（因为中间有其他事务提交了插入/删除）

**并发事务处理带来的问题解决办法：**

- “更新丢失”通常是应该完全避免的。但防止更新丢失，并不能单靠数据库事务控制器来解决，需要应用程序对要更新的数据加必要的锁来解决，因此，防止更新丢失应该是应用的责任。
- “脏读”、"不可重复读”和“幻读”，其实都是数据库读一致性问题，必须由数据库提供一定的事务隔离机制来解决：
    - 一种是加锁：在读取数据前，对其加锁，阻止其他事务对数据进行修改。
    - 另一种是数据多版本并发控制（MultiVersion Concurrency Control，简称 MVCC 或 MCC），也称为多版本数据库：不用加任何锁，通过一定机制生成一个数据请求时间点的一致性数据快照（Snapshot）， 并用这个快照来提供一定级别（语句级或事务级）的一致性读取。从用户的角度来看，好像是数据库可以提供同一数据的多个版本。
